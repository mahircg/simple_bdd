<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BDD_PCKG: Manager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">BDD_PCKG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Manager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Public interface for BDD management.  
 <a href="classManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Manager_8hpp_source.html">Manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1658ff9f18e38ccd9cb8b0b371b9c20b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1658ff9f18e38ccd9cb8b0b371b9c20b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a1658ff9f18e38ccd9cb8b0b371b9c20b">Manager</a> ()</td></tr>
<tr class="memdesc:a1658ff9f18e38ccd9cb8b0b371b9c20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor A simple default constructor,which sets the nextID variable to start from 2. <br/></td></tr>
<tr class="separator:a1658ff9f18e38ccd9cb8b0b371b9c20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322cad25d7007438b3a043ad02253d29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a322cad25d7007438b3a043ad02253d29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a322cad25d7007438b3a043ad02253d29">~Manager</a> ()</td></tr>
<tr class="memdesc:a322cad25d7007438b3a043ad02253d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor Since we do not allocate anything on the heap,nor we do have any virtual functions,body of this function is simply empty. <br/></td></tr>
<tr class="separator:a322cad25d7007438b3a043ad02253d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519e7be1796da18dd76c437d69f93b5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#aa519e7be1796da18dd76c437d69f93b5">createVar</a> (const string &amp;)</td></tr>
<tr class="memdesc:aa519e7be1796da18dd76c437d69f93b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a variable with given variable name and returns its id.  <a href="#aa519e7be1796da18dd76c437d69f93b5"></a><br/></td></tr>
<tr class="separator:aa519e7be1796da18dd76c437d69f93b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace58841925e15af17bd3c3669a23c7b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace58841925e15af17bd3c3669a23c7b2"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#ace58841925e15af17bd3c3669a23c7b2">True</a> () const </td></tr>
<tr class="memdesc:ace58841925e15af17bd3c3669a23c7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a True node,that has a value of 2 This function basically returns the high member of <a class="el" href="classManager.html" title="Public interface for BDD management.">Manager</a> class. <br/></td></tr>
<tr class="separator:ace58841925e15af17bd3c3669a23c7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0186d619266bc86f42baaa3cee87ea4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0186d619266bc86f42baaa3cee87ea4d"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a0186d619266bc86f42baaa3cee87ea4d">False</a> () const </td></tr>
<tr class="memdesc:a0186d619266bc86f42baaa3cee87ea4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a False node,that has a value of 1 This function basically returns the low member of <a class="el" href="classManager.html" title="Public interface for BDD management.">Manager</a> class. <br/></td></tr>
<tr class="separator:a0186d619266bc86f42baaa3cee87ea4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734cbf3169051a6db927515c982aa4c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a734cbf3169051a6db927515c982aa4c6">isVariable</a> (const unsigned &amp;)</td></tr>
<tr class="memdesc:a734cbf3169051a6db927515c982aa4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given node is variable.  <a href="#a734cbf3169051a6db927515c982aa4c6"></a><br/></td></tr>
<tr class="separator:a734cbf3169051a6db927515c982aa4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a0f4b4a64b193e2d95543b5693d251"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a80a0f4b4a64b193e2d95543b5693d251">isConstant</a> (const unsigned &amp;)</td></tr>
<tr class="memdesc:a80a0f4b4a64b193e2d95543b5693d251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given node is a terminal node.  <a href="#a80a0f4b4a64b193e2d95543b5693d251"></a><br/></td></tr>
<tr class="separator:a80a0f4b4a64b193e2d95543b5693d251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac3c08e3ea9c3adac16d4ea00e0f786"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#acac3c08e3ea9c3adac16d4ea00e0f786">topVar</a> (const unsigned &amp;)</td></tr>
<tr class="memdesc:acac3c08e3ea9c3adac16d4ea00e0f786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top variable of a node.  <a href="#acac3c08e3ea9c3adac16d4ea00e0f786"></a><br/></td></tr>
<tr class="separator:acac3c08e3ea9c3adac16d4ea00e0f786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395067e1960330342b9503623498837c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a395067e1960330342b9503623498837c">coFactorTrue</a> (const unsigned, const unsigned)</td></tr>
<tr class="memdesc:a395067e1960330342b9503623498837c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the high co-factor of a function given a variable.  <a href="#a395067e1960330342b9503623498837c"></a><br/></td></tr>
<tr class="separator:a395067e1960330342b9503623498837c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7519619490c44af50bc0341da45f2d7b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a7519619490c44af50bc0341da45f2d7b">coFactorFalse</a> (const unsigned, const unsigned)</td></tr>
<tr class="memdesc:a7519619490c44af50bc0341da45f2d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the low co-factor of a function given a variable.  <a href="#a7519619490c44af50bc0341da45f2d7b"></a><br/></td></tr>
<tr class="separator:a7519619490c44af50bc0341da45f2d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256b5e3ac8517c3757f5823f32f5a555"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a256b5e3ac8517c3757f5823f32f5a555">coFactorTrue</a> (const unsigned)</td></tr>
<tr class="memdesc:a256b5e3ac8517c3757f5823f32f5a555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the high edge of a variable.  <a href="#a256b5e3ac8517c3757f5823f32f5a555"></a><br/></td></tr>
<tr class="separator:a256b5e3ac8517c3757f5823f32f5a555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf80e0b4381bb635321317a1a9518dde"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#acf80e0b4381bb635321317a1a9518dde">coFactorFalse</a> (const unsigned)</td></tr>
<tr class="memdesc:acf80e0b4381bb635321317a1a9518dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the low edge of a variable.  <a href="#acf80e0b4381bb635321317a1a9518dde"></a><br/></td></tr>
<tr class="separator:acf80e0b4381bb635321317a1a9518dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d95b5b0b7d871d23781ae307238fb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a682d95b5b0b7d871d23781ae307238fb">ite</a> (const unsigned, const unsigned, const unsigned)</td></tr>
<tr class="memdesc:a682d95b5b0b7d871d23781ae307238fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic ITE function implementation.  <a href="#a682d95b5b0b7d871d23781ae307238fb"></a><br/></td></tr>
<tr class="separator:a682d95b5b0b7d871d23781ae307238fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f3003cf5489d67b3e2bd21635df2df"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#af5f3003cf5489d67b3e2bd21635df2df">and2</a> (const unsigned, const unsigned)</td></tr>
<tr class="memdesc:af5f3003cf5489d67b3e2bd21635df2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical AND operator.  <a href="#af5f3003cf5489d67b3e2bd21635df2df"></a><br/></td></tr>
<tr class="separator:af5f3003cf5489d67b3e2bd21635df2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ccab2bb135dc565607607bc722b4e1"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a57ccab2bb135dc565607607bc722b4e1">or2</a> (const unsigned, const unsigned)</td></tr>
<tr class="memdesc:a57ccab2bb135dc565607607bc722b4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical OR operator.  <a href="#a57ccab2bb135dc565607607bc722b4e1"></a><br/></td></tr>
<tr class="separator:a57ccab2bb135dc565607607bc722b4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cc96bf2a8dc2cecaa8ece8c6ff56d4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a37cc96bf2a8dc2cecaa8ece8c6ff56d4">xor2</a> (const unsigned, const unsigned)</td></tr>
<tr class="memdesc:a37cc96bf2a8dc2cecaa8ece8c6ff56d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical XOR operator.  <a href="#a37cc96bf2a8dc2cecaa8ece8c6ff56d4"></a><br/></td></tr>
<tr class="separator:a37cc96bf2a8dc2cecaa8ece8c6ff56d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4b653181c504d897ab4a56589a608d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a1c4b653181c504d897ab4a56589a608d">neg</a> (const unsigned)</td></tr>
<tr class="memdesc:a1c4b653181c504d897ab4a56589a608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical NOT operator.  <a href="#a1c4b653181c504d897ab4a56589a608d"></a><br/></td></tr>
<tr class="separator:a1c4b653181c504d897ab4a56589a608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae85672f4e16dd4e40239dd0736bea5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a5ae85672f4e16dd4e40239dd0736bea5">nand2</a> (const unsigned, const unsigned)</td></tr>
<tr class="memdesc:a5ae85672f4e16dd4e40239dd0736bea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical NAND operator.  <a href="#a5ae85672f4e16dd4e40239dd0736bea5"></a><br/></td></tr>
<tr class="separator:a5ae85672f4e16dd4e40239dd0736bea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c84df2ea3c78ddb35b60c6e1c4d1134"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a4c84df2ea3c78ddb35b60c6e1c4d1134">nor2</a> (const unsigned, const unsigned)</td></tr>
<tr class="memdesc:a4c84df2ea3c78ddb35b60c6e1c4d1134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical NOR operator.  <a href="#a4c84df2ea3c78ddb35b60c6e1c4d1134"></a><br/></td></tr>
<tr class="separator:a4c84df2ea3c78ddb35b60c6e1c4d1134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac897c25cc5efa10255465b6f7b3bfc3e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#ac897c25cc5efa10255465b6f7b3bfc3e">getTopVarName</a> (const unsigned &amp;)</td></tr>
<tr class="memdesc:ac897c25cc5efa10255465b6f7b3bfc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the top variable of a variable.  <a href="#ac897c25cc5efa10255465b6f7b3bfc3e"></a><br/></td></tr>
<tr class="separator:ac897c25cc5efa10255465b6f7b3bfc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a30365cb126e094bf0cbaf1d3f8a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#af1a30365cb126e094bf0cbaf1d3f8a07">findNodes</a> (const unsigned &amp;, set&lt; unsigned &gt; &amp;)</td></tr>
<tr class="memdesc:af1a30365cb126e094bf0cbaf1d3f8a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the set with all nodes for the function associated with root node.  <a href="#af1a30365cb126e094bf0cbaf1d3f8a07"></a><br/></td></tr>
<tr class="separator:af1a30365cb126e094bf0cbaf1d3f8a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42f8803468d37f2ce2321af08eea1eb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a42f8803468d37f2ce2321af08eea1eb0">findVars</a> (const unsigned &amp;, set&lt; size_t &gt; &amp;)</td></tr>
<tr class="memdesc:a42f8803468d37f2ce2321af08eea1eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the set with all variables a function depends on.  <a href="#a42f8803468d37f2ce2321af08eea1eb0"></a><br/></td></tr>
<tr class="separator:a42f8803468d37f2ce2321af08eea1eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dbcc3a7d65e154ddf09d9c08300868"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40dbcc3a7d65e154ddf09d9c08300868"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManager.html#a40dbcc3a7d65e154ddf09d9c08300868">printTable</a> () const </td></tr>
<tr class="memdesc:a40dbcc3a7d65e154ddf09d9c08300868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for debugging. <br/></td></tr>
<tr class="separator:a40dbcc3a7d65e154ddf09d9c08300868"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Public interface for BDD management. </p>
<p>BDD management is based on the ROBDD structure,where variables are in an order and BDD is in reduced form in any step of run-time. Usage of the unique table guarantees that every calculated function is in its canonical form. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af5f3003cf5489d67b3e2bd21635df2df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::and2 </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical AND operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First argument of function </td></tr>
    <tr><td class="paramname">g</td><td>Second argument of function Applies the logical AND operator to the variables f and g and returns the new ID,which corresponds to the top variable of x=f AND g </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7519619490c44af50bc0341da45f2d7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::coFactorFalse </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the low co-factor of a function given a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Top variable of the function f </td></tr>
    <tr><td class="paramname">g</td><td>Cofactor Formally,function returns the value of f when g = 0. If f if independent of g(f is less than cofactor),then f is returned. If co-factor equals to f,then low value of f is returned. Last case is g is less than f,where ite operation must be applied until finding cofactor in the function,and returning it. Example: f=ac+bc; coFactorFalse(f,a)=bc </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structBDD__ID.html#a3a3a4521d070e2e2ec497abab7b1e335">BDD_ID::high</a>, and <a class="el" href="structBDD__ID.html#a1d4670e57e3c654821af7a60307a3af3">BDD_ID::low</a>.</p>

</div>
</div>
<a class="anchor" id="acf80e0b4381bb635321317a1a9518dde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::coFactorFalse </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the low edge of a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>ID of the function Similar to coFactorFalse with 1 argument,simply returns the low edge of a function. Example: f=a.c; coFactorFalse(a)=1 </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structBDD__ID.html#a1d4670e57e3c654821af7a60307a3af3">BDD_ID::low</a>.</p>

</div>
</div>
<a class="anchor" id="a395067e1960330342b9503623498837c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::coFactorTrue </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the high co-factor of a function given a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Top variable of the function f </td></tr>
    <tr><td class="paramname">g</td><td>Cofactor Formally,function returns the value of f when g = 1. If f if independent of g(f is less than cofactor),then f is returned. If co-factor equals to f,then high value of f is returned. Last case is g is less than f,where ite operation must be applied until finding cofactor in the function,and returning it. Example: f=ac+bc; coFactorTrue(f,c)=a+b </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structBDD__ID.html#a3a3a4521d070e2e2ec497abab7b1e335">BDD_ID::high</a>, and <a class="el" href="structBDD__ID.html#a1d4670e57e3c654821af7a60307a3af3">BDD_ID::low</a>.</p>

</div>
</div>
<a class="anchor" id="a256b5e3ac8517c3757f5823f32f5a555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::coFactorTrue </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the high edge of a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>ID of the function It simply returns the high edge of a function. Example: f=a; coFactorTrue(a)=2 </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structBDD__ID.html#a3a3a4521d070e2e2ec497abab7b1e335">BDD_ID::high</a>.</p>

</div>
</div>
<a class="anchor" id="aa519e7be1796da18dd76c437d69f93b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::createVar </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>varName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a variable with given variable name and returns its id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>Name of the variable. Note that in the current revision,only the first character of the function name is used. Valid variable names: "a","x","y",etc. Invalid(in other words,unsupported) variable names: "x1","aNeg",etc. Function also performs a check on the unique table to see if the variable to be created has been created before. Since search is made on a hash table,it takes O(1) time and does not increase the execution time in every createVar call,unlike a linear search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1a30365cb126e094bf0cbaf1d3f8a07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Manager::findNodes </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the set with all nodes for the function associated with root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>ID of top variable of f, set list to be filled up Function searches the unique table for nodes. The nodes are searched according to their dependencies to other nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42f8803468d37f2ce2321af08eea1eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Manager::findVars </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the set with all variables a function depends on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>ID of top variable of f, set list to be filled up Function searches the unique table for variables. The variables are searched according to their dependencies to other variables. Multiple occurencies of variables a ignored, only first occurence is stored in set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac897c25cc5efa10255465b6f7b3bfc3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Manager::getTopVarName </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of the top variable of a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>ID of top variable of f Function returns the name of the top variable of a function. Since name of a variable is a part of the key,it is not possible to find it in O(1) time(at least not possible with one-directional hashing) So, a linear search is performed on the unique table to get the variable name. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structBDD__ID.html#a25f2af17e2b46549da87e23a8a4bb2cb">BDD_ID::var</a>.</p>

</div>
</div>
<a class="anchor" id="a80a0f4b4a64b193e2d95543b5693d251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::isConstant </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given node is a terminal node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to be checked This function uses isVariable; if a node is not a variable,it must be a terminal node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a734cbf3169051a6db927515c982aa4c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Manager::isVariable </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a given node is variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to be checked Variable check is based on the assumption we made about the terminal nodes,simply put; every id that has a value other than 1 or 2 is a variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a682d95b5b0b7d871d23781ae307238fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::ite </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic ITE function implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function to be evaluated </td></tr>
    <tr><td class="paramname">g</td><td>High edge of function f </td></tr>
    <tr><td class="paramname">g</td><td>Low edge of function f If-then-else function returns the f.g+!f.h,which is used for representing all basic logical operations. All logical operations are based on this function.Function is implemented as "Efficient Implementation of a BDD Package". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ae85672f4e16dd4e40239dd0736bea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::nand2 </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical NAND operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First argument of function </td></tr>
    <tr><td class="paramname">g</td><td>Second argument of function Applies the logical NAND operator to the variables f and g and returns the new ID,which corresponds to the top variable of x=NOT(f AND g) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c4b653181c504d897ab4a56589a608d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::neg </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical NOT operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First argument of function Applies the negation operator to the variable f and returns the new ID,which corresponds to the top variable of x= NOT f </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c84df2ea3c78ddb35b60c6e1c4d1134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::nor2 </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical NOR operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First argument of function </td></tr>
    <tr><td class="paramname">g</td><td>Second argument of function Applies the logical NOR operator to the variables f and g and returns the new ID,which corresponds to the top variable of x=NOT(f OR g) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57ccab2bb135dc565607607bc722b4e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::or2 </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical OR operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First argument of function </td></tr>
    <tr><td class="paramname">g</td><td>Second argument of function Applies the logical OR operator to the variables f and g and returns the new ID,which corresponds to the top variable of x=f OR g </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acac3c08e3ea9c3adac16d4ea00e0f786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::topVar </td>
          <td>(</td>
          <td class="paramtype">const unsigned &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the top variable of a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>ID of the top variable of function f Function simply returns the node itself. Most likely this function is inlined by compiler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37cc96bf2a8dc2cecaa8ece8c6ff56d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Manager::xor2 </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logical XOR operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>First argument of function </td></tr>
    <tr><td class="paramname">g</td><td>Second argument of function Applies the logical XOR operator to the variables f and g and returns the new ID,which corresponds to the top variable of x=f XOR g </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/import/home/vdscp03/vds_BDD/nicolae/VDS/bdd_package/src/<a class="el" href="Manager_8hpp_source.html">Manager.hpp</a></li>
<li>/import/home/vdscp03/vds_BDD/nicolae/VDS/bdd_package/src/Manager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
